import random
from datetime import timedelta
from django.core.management.base import BaseCommand
from django.utils import timezone
from django.db import transaction, IntegrityError
import logging

from simulator.models import Team, Player, PlayerStatistics, Tournament, Event, Match
from simulator.services.schedule_generator import create_schedule_generator
from simulator.services.commands import SimulateMatchResultCommand

logger = logging.getLogger(__name__)
DEMO_PREFIX = "DEMO_"

class Command(BaseCommand):
    help = 'Generates or deletes sample data (Events, Tournaments, Teams, Players, Matches) for testing.'

    def add_arguments(self, parser):
        parser.add_argument('--generate', action='store_true', help='Generate sample data.')
        parser.add_argument('--delete', action='store_true', help='Delete sample data generated by this script.')
        parser.add_argument('--teams', type=int, default=8, help='Number of teams to generate.')
        parser.add_argument('--players', type=int, default=15, help='Number of players per team.')
        parser.add_argument('--tournaments', type=int, default=2, help='Number of tournaments per event.')
        parser.add_argument('--events', type=int, default=1, help='Number of events to generate.')
        parser.add_argument('--simulate-matches', type=float, default=0.5, help='Fraction of generated matches to simulate results for (0.0 to 1.0).')

    @transaction.atomic
    def handle(self, *args, **options):
        generate = options['generate']
        delete = options['delete']

        if generate and delete:
            self.stdout.write(self.style.ERROR("Cannot use --generate and --delete flags together."))
            return
        elif generate:
            num_teams = options['teams']
            num_players = options['players']
            num_tournaments = options['tournaments']
            num_events = options['events']
            simulate_fraction = options['simulate_matches']

            self.stdout.write(self.style.SUCCESS(f"Generating sample data ({num_events} events, {num_tournaments} tour/event, {num_teams} teams, {num_players} play/team)..."))
            self.generate_data(num_events, num_tournaments, num_teams, num_players, simulate_fraction)
            self.stdout.write(self.style.SUCCESS("Sample data generated successfully."))
        elif delete:
            self.stdout.write(self.style.WARNING(f"Deleting sample data with prefix '{DEMO_PREFIX}'..."))
            self.delete_data()
            self.stdout.write(self.style.SUCCESS("Sample data deleted successfully."))
        else:
            self.stdout.write(self.style.WARNING("Please specify either --generate or --delete flag."))

    def generate_data(self, num_events, num_tournaments_per_event, num_teams, num_players_per_team, simulate_fraction):
        team_names = ["Dragons", "Lions", "Eagles", "Sharks", "Wolves", "Bears", "Falcons", "Cobras", "Vipers", "Titans", "Hawks", "Panthers"]
        player_first_names = ["Alex", "Ben", "Chris", "Dan", "Ethan", "Finn", "Greg", "Hugo", "Ivan", "Jack", "Ken", "Liam"]
        player_last_names = ["Smith", "Jones", "Williams", "Brown", "Davis", "Miller", "Wilson", "Moore", "Taylor", "Anderson", "Thomas", "Martin"]
        positions = ["Goalkeeper", "Defender", "Midfielder", "Forward"]
        tournament_names = ["Cup", "League", "Championship", "Invitational", "Trophy", "Shield"]
        event_names = ["Summer Fest", "Winter Games", "Spring Open", "Autumn Classic"]
        locations = ["Capital Arena", "North Stadium", "East Park", "West Field", "Central Court"]

        created_teams_map = {}
        for i in range(num_teams):
            name = f"{DEMO_PREFIX}{random.choice(team_names)}_{i+1}"
            coach = f"Coach {random.choice(player_last_names)}"
            team, created = Team.objects.get_or_create(name=name, defaults={'coach': coach})
            created_teams_map[name] = team
            if created:
                self.stdout.write(f"Created Team: {name}")
                players_to_create = []
                for j in range(num_players_per_team):
                    p_name = f"{random.choice(player_first_names)} {random.choice(player_last_names)} {i*num_players_per_team + j}"
                    age = random.randint(18, 35)
                    position = random.choice(positions)
                    player = Player(name=p_name, age=age, position=position, team=team)
                    players_to_create.append(player)
                created_players = Player.objects.bulk_create(players_to_create)
                stats_to_create = [PlayerStatistics(player=p, goals=random.randint(0,5), assists=random.randint(0,7), games_played=random.randint(5,15)) for p in created_players]
                PlayerStatistics.objects.bulk_create(stats_to_create)
                self.stdout.write(f"  - Created {len(created_players)} players with stats")
            else:
                 self.stdout.write(f"Team {name} already exists.")

        all_created_teams = list(created_teams_map.values())
        if not all_created_teams:
            self.stdout.write(self.style.WARNING("No teams available to assign to events/tournaments."))
            return

        for i in range(num_events):
            ev_name = f"{DEMO_PREFIX}{random.choice(event_names)} {i+1}"
            start_dt = timezone.now().date() + timedelta(days=i*30)
            end_dt = start_dt + timedelta(days=random.randint(7, 20))
            event, ev_created = Event.objects.get_or_create(
                name=ev_name,
                defaults={'location': random.choice(locations), 'start_date': start_dt, 'end_date': end_dt}
            )
            if ev_created: self.stdout.write(f"Created Event: {ev_name}")

            for j in range(num_tournaments_per_event):
                tourn_name = f"{DEMO_PREFIX}{event.name} {random.choice(tournament_names)} {j+1}"
                tournament, t_created = Tournament.objects.get_or_create(name=tourn_name, defaults={'event': event})
                if t_created:
                    self.stdout.write(f"  - Created Tournament: {tourn_name}")
                    num_teams_in_tourn = random.randint(min(2, len(all_created_teams)), min(len(all_created_teams), 16))
                    teams_for_tournament = random.sample(all_created_teams, num_teams_in_tourn)
                    tournament.teams.add(*teams_for_tournament)
                    self.stdout.write(f"    - Added {len(teams_for_tournament)} teams")

                    if num_teams_in_tourn >= 2:
                        try:
                            sched_start_date = event.start_date + timedelta(days=1)
                            generator = create_schedule_generator('round_robin')
                            created_matches = generator.create_matches_for_tournament(tournament, sched_start_date)
                            self.stdout.write(f"    - Generated {len(created_matches)} matches")
                            tournament.status = Tournament.STATUS_ONGOING
                            tournament.save(update_fields=['status'])

                            matches_to_simulate = random.sample(
                                created_matches,
                                k=int(len(created_matches) * simulate_fraction)
                            )
                            simulated_count = 0
                            for match in matches_to_simulate:
                                try:
                                    sim_command = SimulateMatchResultCommand(match_id=match.id)
                                    sim_command.execute()
                                    simulated_count += 1
                                except Exception as sim_err:
                                     self.stdout.write(self.style.ERROR(f"      - Failed to simulate match {match.id}: {sim_err}"))
                            if simulated_count > 0:
                                 self.stdout.write(f"    - Simulated results for {simulated_count} matches")

                        except Exception as gen_err:
                             self.stdout.write(self.style.ERROR(f"    - Failed to generate/simulate matches for {tourn_name}: {gen_err}"))
                    else:
                         self.stdout.write(self.style.WARNING(f"    - Not enough teams ({num_teams_in_tourn}) to generate schedule for {tourn_name}"))

                else:
                    self.stdout.write(f"  - Tournament {tourn_name} already exists.")

    def delete_data(self):
        deleted_count_info = {}

        demo_tournaments = Tournament.objects.filter(name__startswith=DEMO_PREFIX)
        deleted_info = Match.objects.filter(tournament__in=demo_tournaments).delete()
        deleted_count_info['Matches'] = deleted_info[0] if deleted_info else 0

        deleted_info = demo_tournaments.delete()
        deleted_count_info['Tournaments'] = deleted_info[0] if deleted_info else 0

        demo_teams = Team.objects.filter(name__startswith=DEMO_PREFIX)
        deleted_info = Player.objects.filter(team__in=demo_teams).delete()
        deleted_count_info['Players'] = deleted_info[0] if deleted_info else 0

        deleted_info = PlayerStatistics.objects.filter(player__isnull=True).delete()

        deleted_info = demo_teams.delete()
        deleted_count_info['Teams'] = deleted_info[0] if deleted_info else 0

        deleted_info = Event.objects.filter(name__startswith=DEMO_PREFIX).delete()
        deleted_count_info['Events'] = deleted_info[0] if deleted_info else 0

        for model_name, count in deleted_count_info.items():
             if count > 0:
                  self.stdout.write(f"Deleted {count} demo {model_name}.")



                  